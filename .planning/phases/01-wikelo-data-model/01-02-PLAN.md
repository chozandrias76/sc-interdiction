---
phase: 01-wikelo-data-model
plan: 02
type: execute
---

<objective>
Define Rust types for Wikelo contracts and their requirements.

Purpose: Model Wikelo's trade contracts - what items are required, what rewards are offered, and how to determine contract value. This enables calculating which items are most valuable based on their contract rewards.

Output: Contract types in `crates/intel/src/wikelo/contracts.rs` with WikieloContract, ContractRequirement, and ContractReward types.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Prior plan output:**
@.planning/phases/01-wikelo-data-model/01-01-SUMMARY.md (when exists)

**Codebase patterns:**
@crates/intel/src/ships/types.rs - Type patterns
@crates/intel/src/wikelo/types.rs - Item types from Plan 01

**Key context from PROJECT.md:**
- Wikelo contracts require specific items in specific quantities
- Rewards include weapons, armor, ships, currency
- Don't need to track which contract a player is working toward (out of scope)
- Focus on item value based on what contracts they unlock
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create contracts module</name>
  <files>crates/intel/src/wikelo/contracts.rs, crates/intel/src/wikelo/mod.rs</files>
  <action>
1. Create `crates/intel/src/wikelo/contracts.rs` for contract types
2. Update `crates/intel/src/wikelo/mod.rs` to add:
   ```rust
   mod contracts;
   pub use contracts::*;
   ```

Keep types.rs and contracts.rs as separate files for organization.
  </action>
  <verify>cargo check -p intel passes</verify>
  <done>contracts.rs exists, exported from wikelo module</done>
</task>

<task type="auto">
  <name>Task 2: Define ContractRequirement type</name>
  <files>crates/intel/src/wikelo/contracts.rs</files>
  <action>
Define what a contract requires:

```rust
use super::types::WikieloItem;
use serde::{Deserialize, Serialize};

/// A single requirement for a Wikelo contract.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ContractRequirement {
    /// The item required (by ID reference)
    pub item_id: String,
    /// Quantity of this item needed
    pub quantity: u32,
}

impl ContractRequirement {
    /// Create a new contract requirement.
    #[must_use]
    pub fn new(item_id: impl Into<String>, quantity: u32) -> Self {
        Self {
            item_id: item_id.into(),
            quantity,
        }
    }
}
```

Keep it simple - just item ID and quantity. The registry (Phase 3) will resolve IDs to full WikieloItem data.
  </action>
  <verify>cargo check -p intel passes</verify>
  <done>ContractRequirement type defined</done>
</task>

<task type="auto">
  <name>Task 3: Define ContractReward types</name>
  <files>crates/intel/src/wikelo/contracts.rs</files>
  <action>
Define reward types:

```rust
/// Type of reward from a Wikelo contract.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum RewardType {
    /// Weapon reward
    Weapon,
    /// Armor piece
    Armor,
    /// Ship or vehicle
    Ship,
    /// In-game currency (aUEC)
    Currency,
    /// Consumable items
    Consumable,
    /// Other/miscellaneous
    Other,
}

/// A reward from completing a Wikelo contract.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ContractReward {
    /// Name of the reward item
    pub name: String,
    /// Type of reward
    pub reward_type: RewardType,
    /// Estimated market value in aUEC
    pub estimated_value: Option<u64>,
    /// Description of the reward
    pub description: Option<String>,
}

impl ContractReward {
    /// Create a new contract reward.
    #[must_use]
    pub fn new(name: impl Into<String>, reward_type: RewardType) -> Self {
        Self {
            name: name.into(),
            reward_type,
            estimated_value: None,
            description: None,
        }
    }

    /// Set the estimated value.
    #[must_use]
    pub fn with_value(mut self, value: u64) -> Self {
        self.estimated_value = Some(value);
        self
    }
}
```

Use builder pattern for optional fields (following existing crate patterns).
  </action>
  <verify>cargo check -p intel passes</verify>
  <done>RewardType enum and ContractReward struct defined</done>
</task>

<task type="auto">
  <name>Task 4: Define WikieloContract type</name>
  <files>crates/intel/src/wikelo/contracts.rs</files>
  <action>
Define the main contract type:

```rust
/// A Wikelo trade contract.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WikieloContract {
    /// Unique identifier for this contract
    pub id: String,
    /// Display name of the contract
    pub name: String,
    /// Items required to complete this contract
    pub requirements: Vec<ContractRequirement>,
    /// Rewards for completing this contract
    pub rewards: Vec<ContractReward>,
    /// Whether this contract is repeatable
    pub repeatable: bool,
    /// Optional description/flavor text
    pub description: Option<String>,
}

impl WikieloContract {
    /// Calculate total estimated reward value.
    #[must_use]
    pub fn total_reward_value(&self) -> u64 {
        self.rewards
            .iter()
            .filter_map(|r| r.estimated_value)
            .sum()
    }

    /// Get all unique item IDs required by this contract.
    #[must_use]
    pub fn required_item_ids(&self) -> Vec<&str> {
        self.requirements
            .iter()
            .map(|r| r.item_id.as_str())
            .collect()
    }

    /// Check if this contract requires a specific item.
    #[must_use]
    pub fn requires_item(&self, item_id: &str) -> bool {
        self.requirements.iter().any(|r| r.item_id == item_id)
    }

    /// Get quantity required of a specific item.
    #[must_use]
    pub fn quantity_required(&self, item_id: &str) -> u32 {
        self.requirements
            .iter()
            .filter(|r| r.item_id == item_id)
            .map(|r| r.quantity)
            .sum()
    }
}
```

Include utility methods for querying requirements - these will be useful for intel integration.
  </action>
  <verify>cargo check -p intel passes, cargo clippy -p intel passes</verify>
  <done>WikieloContract type defined with helper methods</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo check -p intel` passes without errors
- [ ] `cargo clippy -p intel` passes without warnings
- [ ] `cargo test -p intel` passes (existing tests still work)
- [ ] All contract types exported from `crates/intel/src/lib.rs`
- [ ] `cargo doc -p intel` generates clean documentation
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- WikieloContract, ContractRequirement, ContractReward, RewardType types defined
- Types follow existing codebase patterns
- Phase 1 complete - ready for Phase 2 (Item Source Research)
</success_criteria>

<output>
After completion, create `.planning/phases/01-wikelo-data-model/01-02-SUMMARY.md` using the summary template.

Final summary should note: "Phase 1 complete. All Wikelo data model types defined. Ready for Phase 2: Item Source Research."
</output>
